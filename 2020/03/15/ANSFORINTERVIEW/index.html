<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="区块链去中心化分布式账本 构成：区块记录了交易记录，每个区块还有一个指向父区块的哈希值（哈希指针），每一个区块都有一个随机数，使用随机数和上一个区块的哈希值计算该区块的哈希值，只有前多少位为0的哈希值才是符合要求的区块，就将他连接在区块链上。防篡改：一旦篡改了某个区块，该区块的哈希值就会改变，那么下一个区块的头指针也要该。所以要篡改的话，就要篡改整个区块链。而一般最后一个区块的hash值都是由系统">
<meta property="og:type" content="article">
<meta property="og:title" content="AnsForInterview">
<meta property="og:url" content="http://example.com/2020/03/15/ANSFORINTERVIEW/index.html">
<meta property="og:site_name" content="Finyaci&#39;s Blog">
<meta property="og:description" content="区块链去中心化分布式账本 构成：区块记录了交易记录，每个区块还有一个指向父区块的哈希值（哈希指针），每一个区块都有一个随机数，使用随机数和上一个区块的哈希值计算该区块的哈希值，只有前多少位为0的哈希值才是符合要求的区块，就将他连接在区块链上。防篡改：一旦篡改了某个区块，该区块的哈希值就会改变，那么下一个区块的头指针也要该。所以要篡改的话，就要篡改整个区块链。而一般最后一个区块的hash值都是由系统">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-03-15T10:53:11.000Z">
<meta property="article:modified_time" content="2020-05-15T09:09:06.000Z">
<meta property="article:author" content="Finyaci">
<meta property="article:tag" content="CS BASIC">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2020/03/15/ANSFORINTERVIEW/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>AnsForInterview | Finyaci's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Finyaci's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Hello!</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/03/15/ANSFORINTERVIEW/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Finyaci">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Finyaci's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          AnsForInterview
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-15 18:53:11" itemprop="dateCreated datePublished" datetime="2020-03-15T18:53:11+08:00">2020-03-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-15 17:09:06" itemprop="dateModified" datetime="2020-05-15T17:09:06+08:00">2020-05-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h1><p>去中心化分布式账本</p>
<p>构成：<br>区块记录了交易记录，每个区块还有一个指向父区块的哈希值（哈希指针），每一个区块都有一个随机数，使用随机数和上一个区块的哈希值计算该区块的哈希值，只有前多少位为0的哈希值才是符合要求的区块，就将他连接在区块链上。<br>防篡改：一旦篡改了某个区块，该区块的哈希值就会改变，那么下一个区块的头指针也要该。所以要篡改的话，就要篡改整个区块链。而一般最后一个区块的hash值都是由系统保留的，所以说任何位置被篡改都可以被检测出来。</p>
<p>51%攻击（比特黄金）：根据区块链最长链准则，算力大于全网络的51%，算出新区块的速度就永远大于其他人，就可以伪造区块。</p>
<h1 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h1><p>可扩展性</p>
<h1 id="1-1-同步和互斥"><a href="#1-1-同步和互斥" class="headerlink" title="1.1 同步和互斥"></a>1.1 同步和互斥</h1><p>进程同步也是进程之间直接的制约关系，为完成某种任务需要多个进程之间的协作，进程间的运行是要按照某种次序执行的，比如说某些进程必须在某些进程之后（或者之前）才能执行，进程间的直接制约关系来源于他们之间的合作。<br>举例：（管道通信，生产者消费者，流水线生产（工序在前工序在后）<br>互斥：对于缓冲区，是互斥访问的<br>同步：缓冲区为空，消费者要等待生产者；缓冲区为满，消费者要等待生产者</p>
<p>进程互斥是进程之间的间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待。只有当使用临界资源的进程退出临界区后，这个进程才会解除阻塞状态。<br>比如（打印机，教室，篮球场，图书）进程B需要访问打印机，但此时进程A占有了打印机，进程B会被阻塞，直到进程A释放了打印机资源,进程B才可以继续执行。概念如图3所示。</p>
<h1 id="线程和进程的区别？"><a href="#线程和进程的区别？" class="headerlink" title="线程和进程的区别？"></a>线程和进程的区别？</h1><p>简而言之，进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高。线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。</p>
<h1 id="算法的五个特性："><a href="#算法的五个特性：" class="headerlink" title="算法的五个特性："></a>算法的五个特性：</h1><p>有穷性：算法在有穷步或有穷时间内完成<br>确定性：指令不会产生二义性，且输入唯一确定输出<br>可行性：算法操作是通过已实现基本运算的有限次执行来实现的<br>输入：<br>输出：</p>
<h1 id="T-n-O-f-n"><a href="#T-n-O-f-n" class="headerlink" title="T(n)=O(f(n))"></a>T(n)=O(f(n))</h1><p>问题的规模为n，算法的执行时间的增长率和函数f（n）的增长率相同</p>
<h1 id="1-3人工智能："><a href="#1-3人工智能：" class="headerlink" title="1.3人工智能："></a>1.3人工智能：</h1><p>机器学习（垃圾邮件过滤）、计算机视觉（图像检测，图像识别）、自然语言处理(自动问答,机器翻译)、推荐系统（淘宝记录购买历史生成个性化推荐，搜索引擎）</p>
<p>自然语言处理（NLP）:是指机器理解并解释人类写作、说话方式的能力。<br>NLP的目标是让计算机／机器在理解语言上像人类一样智能</p>
<h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p>定义：假设用P（Performace）来评估计算机程序在某类任务T（Task）上的性能，若一个程序通过利用经验E（Experience）在T中任务上获得了性能改善，则我们就说关于T和P，该程序对E进行了学习<br>个人理解：通过数据对模型进行训练后，模型可以用于预测新的数据</p>
<p>机器学习的分类：监督学习，无监督学习，强化学习（半监督学习）</p>
<p>深度学习</p>
<h3 id="监督学习："><a href="#监督学习：" class="headerlink" title="监督学习："></a>监督学习：</h3><p>有数据和数据对应的正确标签，从给定的训练数据集中学习出一个函数（模型参数），当新的数据到来时，可以根据这个函数预测结果。</p>
<h3 id="无监督学习："><a href="#无监督学习：" class="headerlink" title="无监督学习："></a>无监督学习：</h3><p>输入数据没有被标记，也没有确定的结果。无监督学习里典型的例子就是聚类。聚类的目的在于把相似的东西聚在一起，而我们并不关心这一类是什么。</p>
<h3 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习:"></a>强化学习:</h3><p>强化学习一开始它并没有数据和标签.只是设立一个评价规则，它是通过环境给出的奖惩来学习</p>
<p>强化学习是一类算法, 是让计算机实现从一开始什么都不懂, 脑袋里没有一点想法, 通过不断地尝试, 从错误中学习, 最后找到规律, 学会了达到目的的方法. 这就是一个完整的强化学习过程. 他要通过一次次在环境中的尝试, 获取这些数据和标签, 然后再学习通过哪些数据能够对应哪些标签, 通过学习到的这些规律, 竟可能地选择带来高分的行为 </p>
<h3 id="深度学习："><a href="#深度学习：" class="headerlink" title="深度学习："></a>深度学习：</h3><p>深度神经网络来解决特征表达的一种学习过程，典型代表，CNN池化层卷积层，全连接层（归一化操作）<br>多用于图像识别领域</p>
<h3 id="各种网络"><a href="#各种网络" class="headerlink" title="各种网络"></a>各种网络</h3><p>CNN 图像识别<br>RNN NLP<br>GAN 生成对抗网络 无监督学习 图像生成<br>判别网络、生成网络</p>
<p>判别网络的目的：就是能判别出来属于的一张图它是来自真实样本集还是假样本集。假如输入的是真样本，网络输出就接近1，输入的是假样本，网络输出接近0，那么很完美，达到了很好判别的目的。<br>生成网络的目的：生成网络是造样本的，它的目的就是使得自己造样本的能力尽可能强，强到什么程度呢，你判别网络没法判断我是真样本还是假样本。</p>
<h1 id="2-2-物联网"><a href="#2-2-物联网" class="headerlink" title="2.2 物联网"></a>2.2 物联网</h1><p>定义：物联网是利用局部网络和互联网等通信技术把传感器，控制器，机器人员和物同过新方式连接在一起，形成人与物，物与物相连，形成信息化远程化管理和智能化网络。</p>
<p>本质：物联网其实是互联网的一个延伸，互联网的终端是计算机（PC、服务器），我们运行的所有程序，无非都是计算机和网络中的数据处理和数据传输。物联网的本质还是互联网，只不过终端不再是计算机（PC、服务器），而是嵌入式计算机系统及其配套的传感器。<br>终端由原来的计算机换成了嵌入式计算机系统及其传感器</p>
<p>应用：<br>农业与物联网的融合，表现在农业种植、畜牧养殖。农业种植利用传感器、摄像头、卫星来促进农作物和机械装备的数字化发展。</p>
<p>而畜牧养殖通过可穿戴设备、摄像头来收集数据，然后分析并使用算法判断畜禽的状况，精准管理畜禽的健康、喂养、位置、发情期等。</p>
<p>家居与物联网的结合，使得很多智能家居类的企业走向物物联动。而智能家居行业的发展首先是单品连接，物物联动处于中间阶段，最终阶段是平台集成。</p>
<p>建筑与物联网的结合，体现在节能方面，与医院医疗设备的管理类似，智慧建筑对建筑设备感知，可以节约能源，同时减少运维的人员成本。<br>具体是用电照明、消防监测、智慧电梯、楼宇监测等方面。</p>
<p>传统的安防依赖人力，而智能安防可以利用设备，减少对人员的依赖。最核心的是智能安防系统，主要包括门禁、报警、监控，视频监控用的比较多，同时该系统可以传输存储图像，也可以分析处理。</p>
<p>具体应用在智能公交车、共享单车、车联网、充电桩监测、智能红绿灯、智慧停车等方面。而互联网企业中竞争较为激烈的方面是车联网。</p>
<h1 id="2-3-数据结构的作用"><a href="#2-3-数据结构的作用" class="headerlink" title="2.3 数据结构的作用"></a>2.3 数据结构的作用</h1><p>可以有效地使用计算机、充分发挥计算机的性能<br>某些场景用某些数据结构运行效果会更加高效，</p>
<ol>
<li><p>在查询操作更多的程序中，你应该用顺序表（线性表的顺序存储）；而增删操作更多的程序中，你要使用链表（每个节点中存放数据和下一个数据的地址）</p>
</li>
<li><p>很多涉及后入先出的问题，例如函数递归就是个栈模型、Android的屏幕跳转就用到栈</p>
</li>
<li><p>对于先入先出要排队的问题，你就要用到队列，例如多个网络下载任务，我该怎么去调度它们去获得网络资源呢？再例如操作系统的进程（or线程）调度，我该怎么去分配资源（像CPU）给多个任务呢？肯定不能全部一起拥有的，资源只有一个，那就要排队</p>
</li>
</ol>
<p>递归: 名词解释：由外到里、由里到外串行运行的过程，直到所有的由外到里“递出去”再由里到外全部“归回来”，该过程也就结束了<br>表现形式：自己调用自己</p>
<p>迭代：重复执行一系列运算步骤，前一次的输出作为后一次的输入，循环体内 i=i+1；</p>
<h1 id="2-4-WEB编程语言"><a href="#2-4-WEB编程语言" class="headerlink" title="2.4 WEB编程语言"></a>2.4 WEB编程语言</h1><p>JavaScript HTML CSS(层叠样式表) PHP JAVA Python</p>
<h1 id="3-1-TCP"><a href="#3-1-TCP" class="headerlink" title="3.1 TCP"></a>3.1 TCP</h1><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>A和B建立TCP连接</p>
<ol>
<li>A的试图向B发起连接 - 同步位SYN置1，随机选取序号seq=x 和B建立连接</li>
<li>B收到A的请求后，首先要对A确认，其次要和B同步序号 - 确认位ACK置1，确认号ack=x+1，同时同步位SYN置1，也随机选取序号seq=y</li>
<li>A要对B进行确认，表示自己已经收到了B的序号 ACK置1，确认号ack=y+1</li>
</ol>
<p>为什么不是两次：防止已经失效的连接传递到了接收端而浪费系统资源 A传给B的请求连接由于网络阻塞延迟到达，而A此时并不需要和B通信，于是B就会一直等待A的数据包</p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>请求-确认-释放-确认</p>
<p>A向B发送链接释放报文，并停止发送数据<br>B收到A的释放请求先予以确认但不立即关闭，此时B又要发送的数据还可以继续发送<br>B数据发送完毕就向A发送链接释放报文，等待A的确认<br>A接到B的连接释放报文后，对B予以确认，B收到后就可以正式关闭连接。而此时A要等待两个MSL后才最终关闭连接</p>
<p>2MSL：</p>
<ol>
<li>防止A发送给B的确认B没有收到，此时B会超时重传链接释放报文</li>
<li>经过2MSL本连接的所有报文段都会从本网络消失</li>
</ol>
<p>发送方：终止等待1-等待B对于A的确认 终止等待2-等待A的终止 时间等待<br>接收方：关闭等待 最后确认</p>
<p>保活计时器：检测客户端状态，若客户端在一定时间内没有响应，就关闭与此客户端的连接，减少服务端的资源占用</p>
<h1 id="3-2"><a href="#3-2" class="headerlink" title="3.2"></a>3.2</h1><p>信息安全是指对信息网络的硬件、软件及数据进行保护，不受偶然的或者恶意的原因而遭到破坏、更改、泄露，系统连续可靠正常地运行，信息服务不中断。</p>
<p>信息安全的实现目标<br>◆ 真实性：对信息的来源进行判断，能对伪造来源的信息予以鉴别。<br>◆ 保密性：保证机密信息不被窃听，或窃听者不能了解信息的真实含义。<br>◆ 完整性：保证数据的一致性，防止数据被非法用户篡改。<br>◆ 可用性：保证合法用户对信息和资源的使用不会被不正当地拒绝。<br>◆ 可控制性：对信息的传播及内容具有控制能力。</p>
<p>主要的信息安全威胁<br>◆ 窃取：非法用户通过数据窃听的手段获得敏感信息。<br>◆ 截取：非法用户首先获得信息，再将此信息发送给真实接收者。<br>◆ 伪造：将伪造的信息发送给接收者。<br>◆ 篡改：非法用户对合法用户之间的通讯信息进行修改，再发送给接收者。<br>◆ 拒绝服务攻击：攻击服务系统，造成系统瘫痪，阻止合法用户获得服务。<br>◆ 行为否认：合法用户否认已经发生的行为。<br>◆ 非授权访问：未经系统授权而使用网络或计算机资源。<br>◆ 传播病毒：通过网络传播计算机病毒，其破坏性非常高，而且用户很难防范。</p>
<p>对称加密:发送者和接收者使用同样的公钥私钥进行加密解密<br>非对称加密：发送者用接收者的公钥加密，接收者用自己的私钥加密<br>数字签名：发送者使用自己的私钥加密，接收者用发送者的公钥解密 发送者不能对报文抵赖，接收者可以核实发送者对报文的签名，接收者无法伪造报文的签名 表面发送者是谁，不能证明发送者就是发送者<br>数字证书：CA作为第三方，证明发送者公钥的合法身份，而不是其他人冒名</p>
<h1 id="3-3"><a href="#3-3" class="headerlink" title="3.3"></a>3.3</h1><p>指针是什么：指针的传递本质上是值传递，它是一个变量，变量存储的是一个地址，指向内存的一个存储单元；<br>引用是什么：而引用和原来变量是同一个东西，是它的一个别名。但内部是存放引用对象的地址<br>区别：</p>
<ol>
<li>引用不可以为空（不能引用一个不存在的变量）。而指针可以时空值（空地址）</li>
<li>初始化：引用创建时必须初始化，指针可以在任何时候被初始化</li>
<li>指针可以有多级，但是引用只有一级。但可以用指针的引用来替代二级指针</li>
<li>值是否可改变：指针的值在初始化后可以改变而，引用的值在初始化之后就不能改变了。</li>
<li>Sizeof引用得到的是所指向的变量的大小，而指针指的是本身大小。</li>
</ol>
<h1 id="3-4"><a href="#3-4" class="headerlink" title="3.4"></a>3.4</h1><h2 id="c-支持java不支持"><a href="#c-支持java不支持" class="headerlink" title="c++支持java不支持"></a>c++支持java不支持</h2><ol>
<li>缺省函数参数：Java不支持缺省函数参数，而c++支持 </li>
<li>操作符重载：Java不支持操作符重载，而c++支持操作符重载的突出特征，在Java中虽然类大体上可以实现这样的功能，但操作符重载的方便性仍然丢失了不少。Java语言不支持操作符重载是为了保持Java语言尽可能简单。</li>
<li>goto语句：Java不提供goto语句，它虽然指定goto作为关键字，但不支持它的使用。C++还保留了goto语句，但它会引起了程序结构的混乱，不易理解。</li>
<li>Java中没有预处理功能，预处理程序虽然可以很方便地达到许多功能，但是站在软件工程的角度上看，对整个软件的维护其实是很不利的。</li>
</ol>
<h2 id="java支持c-不支持"><a href="#java支持c-不支持" class="headerlink" title="java支持c++不支持"></a>java支持c++不支持</h2><ol>
<li>垃圾回收机制：c++用析构函数，手动释放内存，java自动回收（java中有析构函数，但我们一般用不到它）</li>
<li>异常 JAVA中的异常机制用于捕获例外事件，增强系统容错能力，而C++则没有如此方便的机制。</li>
<li>Java有super关键字，指代父类对象，通常被用于调用父类的构造方法或一般方法C++则没有super关键字</li>
<li>Java有package，可以将类组织起来，便于打包和部署，也有利于类的安全。C++没有这个概念，一个类可以被任意类访问</li>
</ol>
<h2 id="都支持的但有区别"><a href="#都支持的但有区别" class="headerlink" title="都支持的但有区别"></a>都支持的但有区别</h2><ol>
<li>多重继承：c++支持多重继承，Java不支持多重继承，但允许一个类继承多个接口，实现了c++多重继承的功能。（多继承坏处：拥有相同名字的实例变量，拥有相同名字的方法子类也没有对其重载，将会产生歧义）</li>
<li>抽象函数和纯虚函数：java中的抽象函数是只有函数声明，没有方法体，JDK8之后的可以有方法体，非静态方法必须要用default修饰。而c++中的纯虚函数是可以有方法体，在c++中，子类还可以调用父类的纯虚函数</li>
<li>两者都有this，指代当前对象</li>
<li>多线程。C++11支持多线程</li>
</ol>
<h2 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h2><ol>
<li>java运行在虚拟机上，而c++都是直接编译成可执行文件，是否能跨平台主要看你用到的编译器特性是否有多平台支持。</li>
<li>因为c和c++是直接编译成可执行文件，所以运行效率要比java高。</li>
</ol>
<h1 id="4-1"><a href="#4-1" class="headerlink" title="4.1"></a>4.1</h1><p>区别：<br>分配依据不同：IP地址在主机加入网络后才会生成，基于网络拓扑，而MAC地址刷在网卡的ROM，出场时就设置好了，一般是不会改的<br>是否可改变：其IP地址可变（但必须唯一），而MAC地址不可变<br>地址格式不同：IP地址32位为点分十进制，MAC地址48位冒号分十六进制<br>运行的层不同：IP地址是在网际层，提供主机与主机的通信，MAC地址是在数据链路层，</p>
<p>联系：IP地址可经过ARP解析为MAC地址，数据帧在传送过程中最终还是以MAC地址进行传递的，传输过程中数据报的源IP地址和目的IP地址都是不变的，而MAC地址都是在改变的<br>相同点：IP地址和MAC地址在全球范围内都是唯一的<br>最终的通信还是要是由ARP负责将IP地址映射到MAC地址上来完成的</p>
<p>为什么使用IP地址，IP地址的好处：将不同的异构网络连接在一起，将计算机之间的通信简化，使得每一个被分配IP地址的主机就好像连在一个网络上，避免了硬件地址转换的工作</p>
<h1 id="4-2"><a href="#4-2" class="headerlink" title="4.2"></a>4.2</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>内部排序：<br>选择排序（简单选择排序O(n^2)，堆排序O(nlogn)）<br>交换排序（冒泡排序O(n^2)，快速排序O(nlogn)）<br>插入排序（直接插入排序O(n^2)，希尔排序O(nlogn)）<br>归并排序O(nlogn)<br>基数排序O(kn)=趟数*元素个数 空间复杂度O(kn)=桶的个数*所有待排序元素的个数</p>
<p>外部排序：内存和外存结合排序</p>
<h1 id="4-3"><a href="#4-3" class="headerlink" title="4.3"></a>4.3</h1><p>词法分析阶段是编译过程的第一个阶段，其任务是从左到右对构成源程序的字符进行扫描，确定单词的类型（关键字、标识符、常数、运算符和分隔符），将其转换为词法单元token&lt;种别码，属性值&gt;<br>关键字、标识符（多词一码）、常量、运算符、界限符</p>
<p>语法分析是编译的逻辑阶段。检查是否有语法错误，根据词法单元构造语法分析树</p>
<h1 id="4-4"><a href="#4-4" class="headerlink" title="4.4"></a>4.4</h1><p>进程作为资源分配的基本单位，线程作为资源调度的基本单位<br>多进程每个进程有自己的地址空间，线程则共享地址空间<br>1。速度：线程产生的速度快，线程间的通讯快、切换快等，因为他们在同一个地址空间内。<br>2。资源利用率：线程的资源利用率比较好也是因为他们在同一个地址空间内。<br>3。同步问题：线程使用公共变量/内存时需要使用同步机制还是因为他们在同一个地址空间内。</p>
<p>使用多进程的好处：一个进程出问题不会影响另一个。缺点：资源占用大，进程切换开销大<br>使用多线程好处：使用多线程的话，因为线程共享资源，线程切换的时候代价就会更小，因而有更好的并发性，服务器执行起来速度更快。但是如果一个线程崩溃了，将会影响到该线程所属进程下的其他线程，因为共享内存。</p>
<h1 id="5-1"><a href="#5-1" class="headerlink" title="5.1"></a>5.1</h1><p>运算器 ALU-组合逻辑 在控制器的控制下，进行数据的加工和完成算数运算（加减乘除），逻辑运算（与或非异或），位移，求补等<br>控制器 CU IR PC 时序逻辑 他是一个决策机构，他需要协调和指挥真个计算机操作系统，包括取指令分析指令执行指令。<br>存储器 MAR MDR 用来存放所有数据和程序的部件，他有若干个存储单元每个存储单元都有自己的地址，计算机通过地址对存储单元进行读写。</p>
<h1 id="5-2"><a href="#5-2" class="headerlink" title="5.2"></a>5.2</h1><p>优点：而这些小问题的处理结果，经过处理可合并为原问题的最终结果。由于这些小问题的计算一般是可以并行完成的，从而可以缩短问题的处理时间。</p>
<p>应用：这类机群主要解决大规模科学问题的计算和海量数据的处理，如科学研究、气象预报、计算模拟、图像处理、机器学习、深度学习等等</p>
<h1 id="5-3-软件架构"><a href="#5-3-软件架构" class="headerlink" title="5.3 软件架构"></a>5.3 软件架构</h1><p>架构：软件架构是一个软件系统的蓝图</p>
<p>常见软件架构分类</p>
<p>1）分层架构<br>表现层（presentation）：用户界面，负责视觉和用户互动<br>业务层（business）：实现业务逻辑(实现这些核心功能的代码就叫业务逻辑)<br>持久层（persistence）：提供数据，SQL语句就放在这一层<br>数据库（database） ：保存数据</p>
<p>2）事件驱动架构<br>事件（event）是状态发生变化时，软件发出的通知。<br>事件队列（event queue）：接收事件的入口<br>分发器（event mediator）：将不同的事件分发到不同的业务逻辑单元<br>事件通道（event channel）：分发器与处理器之间的联系渠道<br>事件处理器（event processor）：实现业务逻辑，处理完成后会发出事件，触发下一步操作</p>
<p>3）微核架构<br>微核架构（microkernel architecture）又称为”插件架构”（plug-in architecture），指的是软件的内核相对较小，主要功能和业务逻辑都通过插件实现。<br>内核（core）通常只包含系统运行的最小功能。插件则是互相独立的，插件之间的通信，应该减少到最低，避免出现互相依赖的问题。</p>
<p>4）微服务架构<br>微服务架构（microservices architecture）是服务导向架构（service-oriented architecture，缩写 SOA）的升级。<br>每一个服务就是一个独立的部署单元（separately deployed unit）。这些单元都是分布式的，互相解耦，通过远程通信协议（比如REST、SOAP）联系。</p>
<h1 id="5-4HPC"><a href="#5-4HPC" class="headerlink" title="5.4HPC"></a>5.4HPC</h1><p>定义：HPC是使用很多处理器或者某多台计算机组成计算集群能够实现并行计算的计算系统。</p>
<p>特点：高性能集群上运行的应用程序一般使用并行算法，把一个大的普通问题根据一定的规则分为许多小的子问题，在集群内的不同节点上进行计算。</p>
<p>大数据：在可容忍时间范围我们现有技术无法感知获取管理的数据集合，数据的规模和复杂程度超出了现有技术所能管理的能力<br>特点：<br>巨量-数据量大<br>多样-数据类型多 结构化的非结构化的，文本图片音频，主要是非结构化的数据<br>快变-指数据的实时性，处理数据的能力要跟的上数据的变化<br>价值-数据非常有价值，商业价值，科学价值</p>
<p>应用 ： 结合深度学习 ，个性化推荐 ， 舆情分析系统 ，大数据技术的体现：数据可视化-新冠</p>
<h1 id="6-1-路由算法"><a href="#6-1-路由算法" class="headerlink" title="6.1 路由算法"></a>6.1 路由算法</h1><p>静态路由算法：人工配置<br>动态路由算法：内部网关协议（用于自治系统内部） 外部网关协议（用于自治系统之间）<br>内部网关协议：<br>    RIP（路由信息协议，相邻路由其之间交换路由表，小网络，坏消息传得慢），路由表存放的是到每一个路由器的最佳距离，和下一跳地址<br>    OSPF（开放最短路径优先，洪范法将路由信息传遍网络，得到网络拓扑结构后，用Dijkstra算法获取最短路径，大网络）<br>外部网关协议：BGP协议 一个自治系统至少选择路由器作为一个BGP发言人，BGP发言人之间建立会话交换路由信息<br>特点：不使用代价作为路由标准而使用，而用可达性作为标准（每个自治系统内部情况都是不一样的，好坏的标准也不一样）</p>
<p>RIP（UDP 应用层 距离向量算法）：<br>    和谁交换：只和自己相邻的路由器交换信息<br>    交换什么：目的地址和距离向量和下一跳地址<br>    何时交换：每30s向相邻的路由器发送信息<br>    收敛速度慢，坏消息传得慢<br>OSPF（IP数据报 洪范法）：<br>    和谁交换：路由器将信息发送给所有相邻路由器，每一个相邻的路由器又会将信息发送给它们相邻的路由器<br>    交换什么：传送所有链路状态：本路由器和哪些路由器相邻，以及之间的代价（延时，距离等）<br>    何时交换：链路状态发生变化时发送消息<br>    收敛速度快，不存在坏消息传的慢<br>BGP（TCP 应用层）：<br>    和谁交换：每个自治系统<br>    交换什么：网络可达性信息，到达某网络要经过哪些自治系统<br>    何时交换：发生变化时交换信息</p>
<p>距离向量算法<br>1.修改报文下一跳地址为报文发送路由器的地址，距离向量（跳数）+1<br>2.对比已有路由表，<br>    如果报文中的目的网络不存在，则直接将报文填入路由表<br>    如果报文中的目的网络已存在，<br>        下一跳地址相同，直接更新路由表<br>        下一跳地址不同，则保留距离更小的那个</p>
<h1 id="6-2"><a href="#6-2" class="headerlink" title="6.2"></a>6.2</h1><p>计算机其实一种很笨，很机械的机器，只会按照预定的指令一步步执行， 而计算机语言的特点就是精确、无二意， 它的本质语言是二进制的， 即使是C,Java等高级一点的语言也只不过是包装而已，它的表达能力并没有本质的提升，仍然停留在很低的层次</p>
<p>相同点：<br>1、计算机与人脑都用0.1二进制这种基本的数据处理模式，在人脑上，就是神经网络上的突触导通（1）或不导通（0）；在计算机上，则是晶体管导通或者不导通——可谓惊人地一致；<br>2、CPU根据程序起到控制作用，人脑根据想法目标进行行动<br>3、可以归为相同点：人具有学习能力（计算机机器学习）</p>
<p>不同点：<br>1、人有主观能动性，人脑可以自己产生“目标”，进而为完成目标而调用大脑的思维和信息等其它资源，而计算机的“目标”则完全是外部设定的，或者说是人脑赋予的。<br>2、人有意识情感，随着人工智能的发展，或许意识和情感可以量化。<br>3、计算机是使命必达的，一切按照程序设定，确定性（输入决定输出），人就不一样，人的行为会受到各种因素（环境时间地点）影响，同一件事情，在不同环境下，完全有可能做出不同的行为。举例子战争<br>4、人会出错，计算机出错的概率极低（只要程序没问题，计算机硬件没有故障，没有人为破坏），在特定情况下计算机可靠性强于人</p>
<h1 id="6-3-关系型数据库的查询优化"><a href="#6-3-关系型数据库的查询优化" class="headerlink" title="6.3 关系型数据库的查询优化"></a>6.3 关系型数据库的查询优化</h1><p>查询处理4阶段：查询分析（词法分析语法分析 识别语句中的各个成分）、查询检查（语义检查 各个成分是否存在和有效）、查询优化、查询执行</p>
<p>查询优化两方面：代数优化（逻辑优化） 物理优化（非代数优化）<br>代数优化就是通过关系代数表达式的等价代换，就是改变操作的组合顺序<br>主要有基于查询树的启发式优化：<br>1）先做选择运算，选择运算和投影运算可以一并执行<br>2）投影和前或后的双目运算符结合起来</p>
<p>物理优化式通过底层存储路径和操作算法优化<br>主要有基于启发式规则的和基于代价估算的优化方法<br>代价=I/O代价+内存代价+CPU代价+通信代价</p>
<h1 id="6-4-四种数据逻辑结构"><a href="#6-4-四种数据逻辑结构" class="headerlink" title="6.4 四种数据逻辑结构"></a>6.4 四种数据逻辑结构</h1><p>① 第一种是集合，集合中任何两个数据元素之间都没有逻辑关系,组织形式松散.<br>② 第二种是线性结构，线性结构中的结点按逻辑关系依次排列形成一个“锁链”. 数组队列链表栈<br>③ 第三种是树形结构，树形结构具有分支、层次特性,其形态有点象自然界中的树.<br>④ 第四种是图状结构，图状结构中的结点按逻辑关系互相缠绕,任何两个结点都可以邻接</p>
<h1 id="7-1快速排序"><a href="#7-1快速排序" class="headerlink" title="7.1快速排序"></a>7.1快速排序</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul>
<li>时间复杂度（最优）：O(nlgn) 每次都平均切分，对数级减小</li>
<li>时间复杂度（平均）：O(nlgn)</li>
<li>时间复杂度（最差）：O(n^2) 每次都选到最值，此时切分一边是空的，另一边元素为n-1，每次规模减小1</li>
</ul>
<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><ol>
<li>先找一个切分元素，这个元素可以随机选择，但选择是整个数组的中位数时，效率最高</li>
<li>将所有比该元素小的都移到该元素的左边，比它大的都移动到它右边</li>
<li>这个切分元素将数组分为两部分，对这两部分分别进行如上操作，这样递归的执行下去，就可以完成排序</li>
</ol>
<p>PS：第二步移动元素的方法：<br>设置头指针和末尾指针，分别从前往后和从后往前扫描，当头指针指向的元素大于切分元素的值时，头指针停止移动，当末尾指针指向的值小于切分元素时，末尾指针停止移动，交换头尾指针指向的内容；之后继续移动步骤，直到头尾指针相遇，此时交换切分元素和头尾指针停止所指向的元素，第一次排序就结束了</p>
<h2 id="快速排序的特点："><a href="#快速排序的特点：" class="headerlink" title="快速排序的特点："></a>快速排序的特点：</h2><ul>
<li>每一次寻找到的切分元素都将会被排定，一次排定一个元素（左边的都不比它大，右边的都不比它小）</li>
<li>左边先有序</li>
<li>当递归调用到一定程度，该数组中的个数将会很少，两到三个，子过程将数组局部先有序</li>
</ul>
<h1 id="7-2多态：事物的多种形态"><a href="#7-2多态：事物的多种形态" class="headerlink" title="7.2多态：事物的多种形态"></a>7.2多态：事物的多种形态</h1><h2 id="多态的实现方式："><a href="#多态的实现方式：" class="headerlink" title="多态的实现方式："></a>多态的实现方式：</h2><ol>
<li>编译时多态：编译期决定目标方法；重载，同名不同参；泛型编程就是建立一个模板，通过输入不同数据类型实现想要的功能</li>
<li>运行时多态：运行期决定目标方法；父类引用指向子类对象，继承，重写，同名同参<br>C++：多态是在不同继承关系的类对象，去调同一函数，产生了不同的行为。<br>Java：子类对象的同名的不同方法可以使用父类的一个接口（行为）实现</li>
</ol>
<h2 id="C-虚函数多态实现原理-将虚表中的地址改为重写后函数的地址"><a href="#C-虚函数多态实现原理-将虚表中的地址改为重写后函数的地址" class="headerlink" title="C++虚函数多态实现原理:将虚表中的地址改为重写后函数的地址"></a>C++虚函数多态实现原理:将虚表中的地址改为重写后函数的地址</h2><ol>
<li>基类对象含有一个指针，该指针指向基类中所有虚函数的地址表。派生类对象将含有一个指向独立地址表的指针。</li>
<li>如果派生类提供了基类虚函数的重定义，该虚函数表将保存新函数的地址。即就是虚函数覆盖实际是对虚函数表中的虚函数的地址的覆盖。</li>
<li>如果派生类定义了新的虚函数，则该函数的地址将被加入到虚函数表中。注意，无论类中是一个还是多个虚函数，都只需在对象中添加一个地址成员，只是表的大小不同。</li>
</ol>
<h2 id="多态好处："><a href="#多态好处：" class="headerlink" title="多态好处："></a>多态好处：</h2><p>1、提高了代码的维护性(继承保证)<br>2、提高了代码的扩展性(由多态保证)</p>
<h2 id="多态的弊端："><a href="#多态的弊端：" class="headerlink" title="多态的弊端："></a>多态的弊端：</h2><ol>
<li>无法使用子类的独有功能（子类有定义，但父类没有，解决方法向下转型）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;show fu&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;show zi&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;method zi&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DuoTaiDemo3</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//测试</span></span><br><span class="line">		Fu f = <span class="keyword">new</span> Zi();</span><br><span class="line">		f.show();</span><br><span class="line">		f.method();<span class="comment">//报错，因为fu类中没有method方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>在C++中，为了允许运行时动态决定哪个函数被调用，一个函数必须用virtual修饰。virtual关键字被自动继承，用以支持多态<br>凡是没有用virtual修饰的成员函数（包括static）都是静态绑定的，即在编译时决定调用哪个版本</p>
<p>程序运行时，同名的函数调用会绑定到不同的函数实现代码上，而且这种对应只能在运行时确定，这种多态方式叫做运行时多态。运行时多态是通过继承和虚函数，在程序执行时动态绑定实现的。</p>
<p>编译器能够根据传给函数的实际参数来跟重载函数进行匹配，根据一定的规则找到最佳的匹配函数版本后再调用。这样一个函数名实际对应的是多个不同的函数实现。这就是一种多态的方式。由于这种多态在编译的时候就能确定所调用的函数并进行绑定，所以称为编译时多态。</p>
<p>区别：</p>
<p>函数重载处理的是同一层次上的同名函数问题，而虚函数处理的是不同派生层次上的同名函数问题，前者是横向重载，后者可以理解为纵向重载。</p>
<p>由于编译时多态是在编译的时刻就确定了需要绑定的函数，不需要程序执行的时候调用函数的匹配，所以速度快，程序执行效率高。而运行时多态则需要在程序执行的时候才能从多个同名的函数中确定调用的具体函数，所以执行效率不高。但是运行时多态提供了程序设计灵活的拓展性、问题的抽象性和代码的可维护性等优点</p>
<p>举例：<br>这么说把,一群动物赛跑,乌龟有乌龟的跑法,兔子有兔子的跑法.<br>那么,我们可以写一个Animal类,它又一个虚方法Run.<br>Rabbit类继承自Animal,重写了Run方法,实现为兔子的跑法.<br>Tortoise类也继承自Animal,重写了Run方法,实现为乌龟的跑法.<br>那么我们可以在一个Animal数组里面装进去许多Rabbit和Tortoise对象,也可以是其他继承自Animal的类型.<br>然后我们直接一个foreach调用里面所有对象的Run方法,不用管它到底是兔子还是乌龟还是别的什么,它门自己就会根据自己实际的类型调用相应的Run版本.也就实现了动物赛跑.</p>
<h1 id="7-3-IPv6与IPv4的区别与联系"><a href="#7-3-IPv6与IPv4的区别与联系" class="headerlink" title="7.3 IPv6与IPv4的区别与联系"></a>7.3 IPv6与IPv4的区别与联系</h1><ol>
<li>地址格式： 点分十进制 冒号分十六进制</li>
<li>更大的地址空间： IPv4 32位 IPv6 128位</li>
<li>IPv6和IPv4数据报不兼容，IPv6简化了头部报文格式，比如：IPv6中就去除了首部检验和字段，因为差错检测的功能由传输层中TCP和UDP负责；IPv6中TTL字段改为跳数</li>
<li>IPv6首部报文8字节对齐，IPv4为4字节</li>
<li>IPv6即插即用不需要DHCP</li>
<li>IPv6除了支持单播和多播还允许支持任播（给一组中的一个主机）</li>
</ol>
<h2 id="IPv4到IPv6过渡"><a href="#IPv4到IPv6过渡" class="headerlink" title="IPv4到IPv6过渡"></a>IPv4到IPv6过渡</h2><ol>
<li>双栈协议 主机或路由器可以同时使用IPv6和IPv4协议</li>
<li>隧道技术 IPv6数据报可以转换成IPv4数据报</li>
</ol>
<h1 id="8-1"><a href="#8-1" class="headerlink" title="8.1"></a>8.1</h1><p>C 面向过程语言 编译型语言<br>C++ C的基础上的面向对象语言 编译型语言<br>C# 面向微软公司.NET平台的具有面向对象特性的编程语言（取消了多继承） 解释型语言<br>Java 纯面向对象语言，运行需要JVM 解释型语言<br>java文件先编译成与平台无关的.class的字节码文件，然后.class的字节码文件既可以在Windows平台上的java虚拟机（JVM）上进行解释运行，也可以在Linux平台上的JVM上解释运行；而JVM的翻译过程时解释性的，JVM从.class的字节码文件中读出一条指令，翻译一条指令，然后执行一条指令，这个过程就称为java的解释执行<br>Python 面向对象型的解释型语言</p>
<p>编译型应用：开发操作系统、大型应用程序、数据库系统 速度要求高，C/C++<br>解释型应用：网页脚本、服务器脚本及辅助开发接口 对速度要求不高、对不同系统平台间的兼容性有一定要求的程序 Java、JavaScript、VBScript、Perl、Python、Ruby、MATLAB</p>
<h1 id="8-2-常见最短路径算法"><a href="#8-2-常见最短路径算法" class="headerlink" title="8.2 常见最短路径算法"></a>8.2 常见最短路径算法</h1><h2 id="Folyd"><a href="#Folyd" class="headerlink" title="Folyd"></a>Folyd</h2><ul>
<li>Folyd求解的问题：各个顶点到其余所有点的最小距离</li>
<li>DIS(v1,v2) &lt; DIS(v1,v3)+DIS(v3,v2)</li>
<li>O(n^3) 三从循环 中间点 起始点 终点</li>
</ul>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><ul>
<li>ABC三个点，B为中间点 如果AB+BC的距离小于AC的距离那么就选择AC作为最短路径</li>
<li>对图上所有点都进行如上操作，每次操作都更新 前驱表和距离表（使用邻接矩阵）</li>
<li>三重循环之后就能得到最终结果</li>
</ul>
<h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><ul>
<li>不能求解权值为负数的图</li>
<li>O(n^2)</li>
<li><p>n个点要进行n次循环，每一次只获得一个点的最短路径，对于每个点要也要进行遍历找到相邻的点进行比较，邻接矩阵n行n列，一个点的相邻点有n-1个+1和自己相邻的节点</p>
</li>
<li><p>Dijkstra求解的问题：一个点到其余所有点的最小距离</p>
</li>
<li>到某一个点的最短路径要么是，起始点直接到该点的距离，要么是起始点经某个已求得的最短路径的点再到该点的距离</li>
</ul>
<h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><ul>
<li>目的：求出起始点到每一个点的最短距离</li>
<li>初始状态设置一个集合，集合存储的是起始点到各相邻点的距离，如果不相邻就用正无穷或者一个很大的数表示；</li>
<li>每次都选取最短的路径（贪心算法的体现），最短路径的选取要比较两种情况，第一种，下一个要求的顶点和起始点直接相连的；第二种，起始点经过那些已经求得最短路径的顶点再到下一顶点的距离之和（这一类也有多种情况，因为那些已经求得最短路径的点不止一个），选取这些情况下面总路径最短的那一个。</li>
<li>重复以上过程，距离集合中起始点到各点的距离会不断减小，直至最后一个点，这就体现了寻找最短路径的过程</li>
</ul>
<h1 id="8-3"><a href="#8-3" class="headerlink" title="8.3"></a>8.3</h1><p>面向过程：就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了<br>面向对象：封装继承多态<br>封装：就是把一些属性和方法封装到一个类里。<br>继承：就如子类继承父类的一些属性和方法。<br>多态：就如一个父类有多个不同特色的子类。</p>
<h1 id="8-4"><a href="#8-4" class="headerlink" title="8.4"></a>8.4</h1><p>黑盒测试：把软件系统当作一个“黑箱”，无法了解或使用系统的内部结构及知识。从软件的行为，而不是内部结构出发来设计测试.<br>白盒测试：设计者可以看到软件系统的内部结构，并且使用软件的内部知识来指导测试数据及方法的选择。<br>动态测试：<br>静态测试：</p>
<p>从测试是手动还是自动上分类：<br>Manual Test 手动测试    测试人员用鼠标去手动测试 （测试GUI）<br>Automation 自动化测试    用程序测试程序 （测试API）</p>
<p>从测试的目的分类：<br>Unit Test 单元测试     在最低的功能/参数上验证程序的准确性,比如测试一个函数的正确性(开发人员做的)<br>Functional Test 功能测试     验证模块的功能  （测试人员做的）<br>Integration Test 集成测试     验证几个互相有依赖关系的模块的功能 （测试人员做的）<br>Scenario Test  场景测试     验证几个模块是否能完成一个用户场景 （测试人员做的）<br>System Test  系统测试     对于整个系统功能的测试 （测试人员做的）<br>Alpha 测试     软件测试人员在真实用户环境中对软件进行全面的测试 （测试人员做的）<br>Beta 测试     真实的用户在真实的用户环境中进行的测试, 也叫公测   （最终用户做的）</p>
<p>非功能测试：<br>Stress test 压力测试     验证软件在超过负载设计的情况下仍能返回正确的结果，没有崩溃<br>Load test 负载测试     测试软件在负载情况下能否正常工作<br>Compatibility Test 兼容性测试</p>
<p>Ad hoc Test 探索性测试：自己按照自己的思路，随便点点。 如果测试GUI，Ad hoc能发现大量的bug</p>
<h1 id="9-1"><a href="#9-1" class="headerlink" title="9.1"></a>9.1</h1><p>简单的说就是把互联网技术应用到移动通信技术中，开发任务就是手机，平板等移动终端开发</p>
<p>原生app：Android app掌握java语言（具体是java SE）了解Eclipse/MyEclipse开发工具<br>iOS app掌握objective-c语言，了解Xcode<br>web app：html（HTML5）+css（CSS3）+JavaScript语言混合app：了解专门IDE和开发语言</p>
<p>移动通讯：微信 小程序<br>移动购物：淘宝</p>
<h1 id="9-2"><a href="#9-2" class="headerlink" title="9.2"></a>9.2</h1><h2 id="库是写好的现有的，成熟的，可以复用的代码。库中虽然包含了可执行代码却不能单独执行"><a href="#库是写好的现有的，成熟的，可以复用的代码。库中虽然包含了可执行代码却不能单独执行" class="headerlink" title="库是写好的现有的，成熟的，可以复用的代码。库中虽然包含了可执行代码却不能单独执行"></a>库是写好的现有的，成熟的，可以复用的代码。库中虽然包含了可执行代码却不能单独执行</h2><h2 id="动态静态的区别"><a href="#动态静态的区别" class="headerlink" title="动态静态的区别"></a>动态静态的区别</h2><p>静态链接是在链接阶段，将引用到的库一起链接打包到可执行文件中，成为可执行文件的一部分，程序在运行时与函数库再无瓜葛<br>当多个程序都调用相同函数时，内存中就会存在这个函数的多个拷贝，这样就浪费了宝贵的内存资源。</p>
<p>动态链接库在链接程序时，只是记录了少量必要信息（重定位信息），在实际程序执行时才动态链接库的全部内容将被映射到运行时相应进程的虚地址空间。</p>
<p>对于静态链接，程序执行之前，库就已经链接在可执行文件内<br>对于动态链接，程序执行时，才会访问动态库中的代码段</p>
<h2 id="静态链接库"><a href="#静态链接库" class="headerlink" title="静态链接库"></a>静态链接库</h2><p>  之所以成为静态库，是因为在链接阶段，会将汇编生成的目标文件.o与引用到的库一起链接打包到可执行文件中。因此对应的链接方式称为静态链接。<br>  试想一下，静态库与汇编生成的目标文件一起链接为可执行文件，那么静态库必定跟.o文件格式相似。其实一个静态库可以简单看成是一组目标文件（.o/.obj文件）的集合，即很多目标文件经过压缩打包后形成的一个文件。静态库特点总结：</p>
<p>1    静态库对函数库的链接是放在编译时期完成的。<br>2    程序在运行时与函数库再无瓜葛，移植方便。<br>3    浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。</p>
<p>静态链接库的优点和缺点：<br>1.代码装载速度快，执行速度略比动态链接库快；<br>2.只需保证在开发者的计算机中有正确的.LIB文件，在以二进制形式发布程序时不需考虑在用户的计算机上.LIB文件是否存在及版本问题，可避免DLL地狱等问题。<br>3.使用静态链接生成的可执行文件体积较大，包含相同的公共代码，造成浪费。</p>
<p>动态链接库的优点：</p>
<ol>
<li>方便维护和更改，只需要更换文件就可以</li>
<li>降低耦合度</li>
<li>节省空间，不同程序都可以调用同一个库，资源共享</li>
</ol>
<p>使用DLL也有一个缺点：DLL地狱，也就是几个应用程序在使用同一个共享DLL库发生版本冲突</p>
<h1 id="9-3-TCP与UDP的区别"><a href="#9-3-TCP与UDP的区别" class="headerlink" title="9.3 TCP与UDP的区别"></a>9.3 TCP与UDP的区别</h1><ol>
<li>TCP面向连接，可靠传输，有重传确认机制 UDP无连接，不可靠，无重传确认机制</li>
<li>TCP面向字节流（把应用层数据看作无结构的字节流），UDP面向报文（对于应用层的报文，既不拆分也不合并，加上UDP首部，一次发送一个报文）</li>
<li>TCP只支持一对一，面向连接的 UDP支持一对一，一对多，多对一，多对多</li>
<li>TCP首部至少20字节 UDP只要8个字节</li>
<li>TCP有拥塞控制和流量控制 UDP没有</li>
</ol>
<h1 id="9-4-冯·诺依曼"><a href="#9-4-冯·诺依曼" class="headerlink" title="9.4 冯·诺依曼"></a>9.4 冯·诺依曼</h1><p>冯·诺依曼结构也称普林斯顿结构，<br>提出了计算机系统的五大要素：运算器，控制器，存储器，输入和输出设备<br>指令和数据均用二进制表示，指令和数据同等存放在存储器内<br>指令在存储器中按顺序存放，且程序按顺序执行<br>以运算器为中心，输入输出设备与存储器间的数据通过运算器完成（现代计算机以存储器为中心）</p>
<p>哈佛结构与冯·诺依曼结构处理器相比，处理器有两个明显的特点：使用两个独立的存储器模块，分别存储指令和数据，每个存储模块都不允许指令和数据并存；使用独立的两条总线，分别作为CPU与每个存储器之间的专用通信路径，而这两条总线之间毫无关联。<br>哈佛结构：51单片机、典型的STM32单片机</p>
<h1 id="图灵机"><a href="#图灵机" class="headerlink" title="图灵机"></a>图灵机</h1><p>所谓的图灵机就是指一个抽象的机器，它有一条无限长的纸带，纸带分成了一个一个的小方格，每个方格有不同的颜色。有一个机器头在纸带上移来移去。机器头有一组内部状态，还有一些固定的程序。在每个时刻，机器头都要从当前纸带上读入一个方格信息，然后结合自己的内部状态查找程序表，根据程序输出信息到纸带方格上，并转换自己的内部状态，然后进行移动。</p>
<h1 id="10-1-RISC-CISC"><a href="#10-1-RISC-CISC" class="headerlink" title="10.1 RISC CISC"></a>10.1 RISC CISC</h1><p>CISC(复杂庞大指令数目多):一条指令完成一个基本功能<br>RISC(精简短小指令数目少):多条指令完成一个基本功能，由于CISC指令较多而真正用到的只有20%，所以诞生了RISC</p>
<p>CISC 台式机、笔记本x86架构；一条指令完成一个基本功能所以难以优化；指令流水线难以实现<br>RISC ARM架构 手机平板 功耗较小；多条指令完成一个基本功能所以容易优化；必须使用指令流水线</p>
<h1 id="10-2IP组播："><a href="#10-2IP组播：" class="headerlink" title="10.2IP组播："></a>10.2IP组播：</h1><p>组播是指主机之间“一对一组”的通讯模式，一对多通讯<br>优点：</p>
<ol>
<li>需要相同数据流的客户端加入相同的组共享一条数据流，节省了服务器的负载。具备广播所具备的优点。</li>
<li>IP组播对数据流进行复制转发，所以服务端的总带宽不受客户数量的限制。IP协议允许有2.6亿个组播组，所以其提供的服务可以非常丰富。</li>
<li>使用UDP传输，速度快</li>
</ol>
<p>缺点：<br>1．与单播协议相比没有纠错机制，尽最大努力传输，使用UDP传输，发生丢包错包后难以弥补。</p>
<h2 id="组播分类"><a href="#组播分类" class="headerlink" title="组播分类"></a>组播分类</h2><p>因特网范围内组播：<br>硬件组播：局域网内传播</p>
<h1 id="10-3"><a href="#10-3" class="headerlink" title="10.3"></a>10.3</h1><p>课程的深度：本科都是学习一些基础课程，范围面广，但是具体到某一方向上学的并不深，所以研究生学习的领域更加细化更加精确<br>学习的方式：本科学习都是授课考试的形式，研究生则大多靠自学或者做项目做实验的方式<br>学习的价值：本科一般不会社会的学习创造出比较大的价值，创造价值的途径也不是很多，研究生通过发论文，做项目实际上是对社会有实际贡献的</p>
<h1 id="10-4"><a href="#10-4" class="headerlink" title="10.4"></a>10.4</h1><p>8086独立编址<br>独立编址：不占用存储器，有独立的存取指令和IO端口进行通信<br>统一编址：在内存中划分一块区域，将IO端口映射到内存中</p>
<p>IO端口：CPU与外部设备通信的缓冲电路</p>
<h1 id="11-1-gt-8-1"><a href="#11-1-gt-8-1" class="headerlink" title="11.1 -&gt; 8.1"></a>11.1 -&gt; 8.1</h1><h1 id="11-2"><a href="#11-2" class="headerlink" title="11.2"></a>11.2</h1><ul>
<li>时间复杂度（平均，最好，最坏）：O(nlgn)</li>
<li>空间复杂度：堆排序不要任何辅助数组，只需要一个辅助变量，所占空间是常数与n无关，所以空间复杂度为O(1)</li>
<li><p>每一次比较2*(logn/log2-1)次（深度-1），n个元素比较n-1轮</p>
</li>
<li><p>初始化建堆的时间复杂度为O(n)，排序重建堆的时间复杂度为nlog(n)，所以总的时间复杂度为O(n+nlogn)=O(nlogn)</p>
</li>
<li><p>主要思想：使用二叉堆这种数据结构（大（小）顶堆，任意父节点都比其子节点大（小）），将待排序的元素构建成二叉堆，堆顶元素是最值。取出堆顶元素后，剩余元素继续调整成二叉堆，得到次小值，反复这个过程，直到排序结束</p>
</li>
<li><p>建堆，从最后一个非叶子节点开始（和自己的左右子节点比较，大的元素存放在父节点），从右往左从下往上，依次执行，建完堆后，堆顶元素就是最值</p>
</li>
</ul>
<p>堆排序是简单选择排序的改进：简单选择排序在一趟排序中仅选出最小关键码，没有把一趟比较结果保存下来，因而记录的比较次数较多。堆排序在选出最小关键码的同时，也找出较小关键码，减少了在后面的选择中的比较次数，从而提高了整个排序的效率。</p>
<ul>
<li>大顶堆：非叶子节点均不小于其左右孩子节点的值</li>
<li><p>小顶堆：非叶子节点均不大于其左右孩子节点的值</p>
</li>
<li><p>建堆过程是从最小的非叶子节点开始，下沉元素是从根节点开始</p>
</li>
</ul>
<h1 id="11-3"><a href="#11-3" class="headerlink" title="11.3"></a>11.3</h1><p>一次封锁法：一次性在所有要用到的对象上加锁<br>缺点：降低系统的并发性，数据库是在变化的，很难事先确定哪些对象要上锁</p>
<p>顺序封锁法：按照某个不会引起死锁的顺序给对象加锁<br>缺点：数据库中对象太多，维护这样的封锁顺序很困难；数据库在使用时是在变化的，很难事先确定哪些对象要上锁</p>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="产生死锁的必要条件"><a href="#产生死锁的必要条件" class="headerlink" title="产生死锁的必要条件"></a>产生死锁的必要条件</h2><ol>
<li>互斥：某一时间某个资源只能被一个进程访问</li>
<li>请求和保持：进程已经拥有一个资源，又请求新的资源，而该资源被其他进程占用</li>
<li>不可抢占：资源是不可抢占的，该资源被分配出去在未使用完之前是不可被抢占的</li>
<li>循环等待：死锁的进程一个等待另一个，资源分配图是环形的</li>
</ol>
<h2 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h2><ol>
<li>安全序列，以某种不会引起死锁的资源分配次序给进程分配资源</li>
<li>破坏请求和保持条件：1)把该进程要用到的所有资源都分配给它 2)先给一部分，再请求新的资源时要释放原来占有的资源</li>
<li>破坏不可抢占：选一个代价比较小的，将其资源回收</li>
<li>破坏循环等待：将系统资源分等级，资源请求必须先从低等级开始，就不会产生环</li>
</ol>
<h1 id="11-4-汇编语言"><a href="#11-4-汇编语言" class="headerlink" title="11.4 汇编语言"></a>11.4 汇编语言</h1><p>单片机 单片机程序调试可以用汇编去写，C语言和汇编语言联合编程，调试的时候也可以使用汇编去调试<br>逆向工程 反汇编可以去寻找软件的漏洞，提高软件的安全性</p>
<h1 id="12-1平台无关性"><a href="#12-1平台无关性" class="headerlink" title="12.1平台无关性"></a>12.1平台无关性</h1><p>就是一种语言在计算机上的运行不受平台的约束，一次编译，到处执行</p>
<p>平台无关有两种：源代码级和目标代码级。<br>例如：C和C++是源代码级平台无关，C或C++写的应用程序不用修改只需重新编译就可以在不同平台上运行。<br>而Java编译出来的是字节码，只要平台上安装对应的JRE就可以运行。</p>
<h1 id="12-2-数据库设计的基本步骤"><a href="#12-2-数据库设计的基本步骤" class="headerlink" title="12.2 数据库设计的基本步骤"></a>12.2 数据库设计的基本步骤</h1><ol>
<li>系统需求分析阶段； 分析用户需求，确定用户的实际要求，获取数据字典</li>
<li>概念结构设计阶段； 根据用户需求，建立独立概念模型，一般使用ER图</li>
<li>逻辑结构设计阶段； 将概念模型转换为适合某个DBMS逻辑模型，根据ER图转换为关系模型</li>
<li>物理结构设计阶段； 为逻辑模型选择合适的物理结构，确定数据库的存取方法和存储结构</li>
<li>数据库实施阶段； 根据DBMS提供数据库语言，建立数据库试运行</li>
<li>数据库运行与维护阶段； 数据库的转储和恢复，安全性完整性控制，性能的监督分析改造，重组织重构<br>共六个阶段，常常是六个阶段的往复</li>
</ol>
<h1 id="12-3驱动程序"><a href="#12-3驱动程序" class="headerlink" title="12.3驱动程序"></a>12.3驱动程序</h1><ol>
<li>驱动程序给操作系统提供操作硬件的接口，它的作用就是使操作系统能够正确地识别、管理、使用相应的硬件设备</li>
<li>驱动程序是一个比较特别的软件程序，它具有一般程序的一些特性，是计算机硬件设备与操作系统之间的桥梁</li>
<li>驱动包括主板驱动显卡驱动声卡驱动</li>
</ol>
<h1 id="12-4"><a href="#12-4" class="headerlink" title="12.4"></a>12.4</h1><p>编译程序是把用高级程序设计语言或计算机汇编语抄言书写的源程序，翻译成等价的机器语言格式目标程序的翻译程序<br>解释程序是高级语言翻译程序的一种，它将源语言书写的源程序作为输入，解释一句后就提交计算机执行一句，并不形成目标百程序。就像外语翻译中的“口译”一样，说一句翻一句，不产生全文的翻译文本。</p>
<p>区别：<br>速度：编译程序运行速度更快<br>灵活性：解释程序可以在运行期间修改代码<br>可移植性：编译程序需要在对应平台安装编译器并重新编译，解释程序则只需要安装对应的解释器</p>
<h1 id="软件开发的阶段"><a href="#软件开发的阶段" class="headerlink" title="软件开发的阶段"></a>软件开发的阶段</h1><ol>
<li>问题的定义及规划：主要确定软件的开发目标及其可行性</li>
<li>需求分析：软件需求分析就是回答做什么的问题</li>
<li>软件设计：概要设计和详细设计两个阶段（概要设计就是结构设计，其主要目标就是给出软件的模块结构，用软件结构图表示。详细设计的首要任务就是设计模块的程序流程、算法和数据结构，次要任务就是设计数据库，常用方法还是结构化程序设计方法。 ）</li>
<li>软件编码：把软件设计转换成计算机可以接受的程序，即写成以某一程序设计语言表示的”源程序清单”。</li>
<li>软件测试：以较小的代价发现尽可能多的错误。单元测试集成测试</li>
<li>软件交付用户验收：软件开发者应向用户提交开发的目标安装程序、数据库的数据字典、《用户安装手册》、《用户使用指南》、需求报告、设计报告、测试报告等双方合同约定的产物。</li>
<li>维护是指在已完成对软件的研制（分析、设计、编码和测试）工作并交付使用以后，对软件产品所进行的一些软件工程的活动。即根据软件运行的情况，对软件进行适当修改，以适应新的要求，以及纠正运行中发现的错误。编写软件问题报告、软件修改报告。 </li>
</ol>
<h1 id="13-1软件需求分析"><a href="#13-1软件需求分析" class="headerlink" title="13.1软件需求分析"></a>13.1软件需求分析</h1><h2 id="需求分析的过程"><a href="#需求分析的过程" class="headerlink" title="需求分析的过程"></a>需求分析的过程</h2><p>需求分析的任务是确定系统在功能上需要“实现什么”，而不是考虑如何去“实现”<br>需求抽取-需求规格说明书-需求确认（萨默维尔）</p>
<p>需求抽取：确定软件要实现哪些功能，以及一些软件系统的标准。主要包括功能性需求和非功能性需求（性能约束，外部接口约束，设计约束）</p>
<p>制订需求规格说明书： 将需求的转化为书面文档称为软件需求规格说明书。</p>
<p>需求确认： 对功能的正确性（功能均正确），一致性（功能间无冲突），完整性（所有的功能），以及其它需求给予评价。评审通过才可进行下一阶段的工作,否则重新进行需求分析。</p>
<p>难点：<br>难点，主要体现在以下几个方面。</p>
<p>(1)交流难以达到共识。由于客户和工程师专业知识背景不同，难以进行有效的交流，需求工程师要有正确提出问题的能力，客户要有能够说出自己本意的能力。完美蠕行（交谈期间需求可能不断增长，导致超出项目成本或者进度等）<br>(2)需求时常变化。在整个软件生存周期，需求常会随着时间和业务而有所变化。有的用户需求经常变化。<br>(3)需求之间的冲突。不同的客户提出的需求可能会有冲突，需求工程师要能有找到他们提出需求的共性和冲突。<br>(4)得到的需求难以达到完备与一致。由于不同人员对系统的需求认识不尽相同，难以消除矛盾歧义，形成完备和一致的定义。</p>
<h2 id="敏捷开发"><a href="#敏捷开发" class="headerlink" title="敏捷开发"></a>敏捷开发</h2><p>敏捷开发（Agile）是一种以人为核心、迭代、循序渐进的开发方法<br>敏捷开发并不追求前期完美的设计、完美编码，而是力求在很短的周期内开发出产品的核心功能，尽早发布出可用的版本。然后在后续的生产周期内，按照新需求不断迭代升级，完善产品。</p>
<h2 id="软件生命周期（软件过程模型）"><a href="#软件生命周期（软件过程模型）" class="headerlink" title="软件生命周期（软件过程模型）"></a>软件生命周期（软件过程模型）</h2><p>瀑布模型 定义-需求分析-系统设计-单元测试-集成测试-运行维护<br>瀑布模型有以下优点<br>1）为项目提供了按阶段划分的检查点。<br>2）当前一阶段完成后，您只需要去关注后续阶段。<br>3）它提供了一个模板，这个模板使得分析、设计、编码、测试和支持的方法可以在该模板下有一个共同的指导。<br>瀑布模型有以下缺点<br>1）各个阶段的划分完全固定，阶段之间产生大量的文档，极大地增加了工作量。<br>2）由于开发模型是线性的，用户只有等到整个过程的末期才能见到开发成果，从而增加了开发风险。<br>3）通过过多的强制完成日期和里程碑来跟踪各个项目阶段。<br>4）瀑布模型的突出缺点是不适应用户需求的变化。</p>
<p>增量式模型 先实现一部分需求，需求的增加通过版本的迭代（升级）完成，直到系统完成。每个中间版本都要执行必需的过程、活动和任务。<br>1、将待开发的软件系统模块化，可以分批次地提交软件产品，使用户可以及时了解软件项目的进展。<br>2、以组件为单位进行开发降低了软件开发的风险。一个开发周期内的错误不会影响到整个软件系统。<br>3、开发顺序灵活。<br>缺点：容易成为边做边改模型</p>
<p>边做边改模型<br>当一个软件产品在没有规格说明或主要设计的情况下被开发时，开发者往往不得不重新对产品编码多次直到他们得到正确稳定的产品。这种开发模型就是边做边改模型。开发者们首先开发出一个产品的最初版本给客户验收，然后开发团队开发一个新的版本再次给客户验收。这个过程一直持续到客户感觉产品满意为止。</p>
<h2 id="需求的分类"><a href="#需求的分类" class="headerlink" title="需求的分类"></a>需求的分类</h2><p>功能性需求<br>非功能性需求：性能需求，外部接口的需求（考虑到未来要和其他软件交互）</p>
<p>功能性需求是整个需求的主体，没有功能性需求就没有非功能性需求<br>非功能性需求对功能需求而言可以是一对多的，即的功能性需求需要某些非功能性需求，而某些并不要</p>
<h3 id="性能约束"><a href="#性能约束" class="headerlink" title="性能约束"></a>性能约束</h3><p>某些功能要达到某些指标</p>
<h3 id="外部接口的约束"><a href="#外部接口的约束" class="headerlink" title="外部接口的约束"></a>外部接口的约束</h3><p>达到交互目的<br>系统接口：系统的其他应用交互<br>用户接口：用户交互<br>硬件接口：硬件交互<br>软件接口：与其他软件产品交互<br>通讯接口：与通讯设施的交互（局域网）</p>
<p>内存约束：易失性存储和永久性存储<br>地点约束：场景需求适应新系统</p>
<h3 id="设计约束"><a href="#设计约束" class="headerlink" title="设计约束"></a>设计约束</h3><p>法规政策，硬件限制（存取容量处理速度），与其他应用的接口，并发操作，审计功能（），语言需求（C++），应用的关键程度（对于医疗军事等关键领域，某些功能不允许出错）</p>
<p>例如：必须用C++编写</p>
<h2 id="需求发现"><a href="#需求发现" class="headerlink" title="需求发现"></a>需求发现</h2><ol>
<li><p>自悟 把自己放在用户的角度</p>
</li>
<li><p>交谈 需求人员与客户沟通，（需求人员要有正确提出问题的能力，客户要有能够说出自己本意的能力）</p>
</li>
</ol>
<ul>
<li>风险： 完美蠕行（交谈期间需求可能不断增长，导致超出项目成本或者进度等）</li>
<li>措施： 定期对交谈结果复审（如果要某些需求要加钱）</li>
</ul>
<ol>
<li>观察 参与到客户的业务中</li>
</ol>
<ul>
<li>风险： 长时期的话会打扰客户</li>
</ul>
<ol>
<li>小组会： 客户和开发人员的联席会议</li>
</ol>
<ul>
<li>难点： 主持人的要求，成员的要求</li>
</ul>
<ol>
<li>提炼： 复审技术文档（其他相似的项目，之前已经有的技术文档）</li>
</ol>
<p>各有优缺点</p>
<h2 id="需求的基本性质"><a href="#需求的基本性质" class="headerlink" title="需求的基本性质"></a>需求的基本性质</h2><p>必要的： 该需求是否必要<br>无歧义的： 设计者和开发者要达成一致<br>可测试的： 能否进行测试，输入必须确定输出，不会说输入会导致不同的输出<br>可追踪的： 一个开发阶段到另一个开发阶段是否可跟踪<br>可测量： </p>
<h2 id="需求规约SRS"><a href="#需求规约SRS" class="headerlink" title="需求规约SRS"></a>需求规约SRS</h2><p>软件的概念模型</p>
<h3 id="SRS的作用"><a href="#SRS的作用" class="headerlink" title="SRS的作用"></a>SRS的作用</h3><ol>
<li>开发者和用户的技术合同</li>
<li>项目管理的控制点</li>
<li>产品设计的起始点</li>
<li>创建产品验收测试和用户指南的基础（验收测试计划）</li>
</ol>
<h1 id="13-2TCP-IP每层用的协议"><a href="#13-2TCP-IP每层用的协议" class="headerlink" title="13.2TCP/IP每层用的协议"></a>13.2TCP/IP每层用的协议</h1><h2 id="TCP-IP-四层"><a href="#TCP-IP-四层" class="headerlink" title="TCP/IP 四层"></a>TCP/IP 四层</h2><p>应用层 运输层 网络层 网络接口层</p>
<h2 id="A-应用层协议"><a href="#A-应用层协议" class="headerlink" title="A 应用层协议"></a>A 应用层协议</h2><p>DNS<br>FTP TFPT<br>HTTP HTTPS<br>TELNET<br>SMTP MIME POP3 IMAP<br>DHCP</p>
<h2 id="B-传输层协议"><a href="#B-传输层协议" class="headerlink" title="B 传输层协议"></a>B 传输层协议</h2><p>TCP 传输控制协议<br>UDP 用户数据报协议<br>使用TCP的协议： SMTP FTP HTTP TELNET BGP<br>内部路由协议：RIP、OSPF<br>外部路由协议：BGP</p>
<p>UDP 用户数据报协议</p>
<h2 id="C-网络层协议"><a href="#C-网络层协议" class="headerlink" title="C 网络层协议"></a>C 网络层协议</h2><p>IP 网际协议<br>ARP 地址解析协议<br>RARP 逆地址解析协议<br>ICMP：网际控制报文协议<br>IGMP：网际组管理协议 使用于多播（1.主机要加入组播组，向路由器发送IGMP报文。路由器收到后，将组播组成员关系发送给因特网上其他路由器 2.路由器定时向组播组成员发送数据报，确认成员的状态，如果一段时间内没有任何一个成员有响应，则判定该组播组已无成员）</p>
<h2 id="D-数据层协议"><a href="#D-数据层协议" class="headerlink" title="D 数据层协议"></a>D 数据层协议</h2><p>CSMA/CD 载波监听多点接入/碰撞协议<br>在争用期内监听，如果没有碰撞则以后就不会有碰撞</p>
<p>PPP点对点协议<br>封装成帧，透明传输，差错检测</p>
<h2 id="E-物理层协议"><a href="#E-物理层协议" class="headerlink" title="E 物理层协议"></a>E 物理层协议</h2><p>RS-232<br>RS-449</p>
<h1 id="13-3"><a href="#13-3" class="headerlink" title="13.3"></a>13.3</h1><p>通过网络（云）获得计算资源，将要计算的程序分解成多个小程序，分发给多部服务器进行计算，将计算的结果合并返回。<br>通过这项技术，可以在很短的时间内完成庞大数据的处理，从而达到强大的网络服务能力。</p>
<h2 id="服务类型"><a href="#服务类型" class="headerlink" title="服务类型"></a>服务类型</h2><p>基础设施即服务 IasS: 提供给消费者的服务是对所有计算基础设施的利用，包括处理CPU、内存、存储、网络和其它基本的计算资源，用户能够部署和运行任意软件，包括操作系统和应用程序。<br>平台即服务 PasS: 客户不需要管理或控制底层的云基础设施，包括网络、服务器、操作系统、存储等，但客户能控制部署的应用程序，也可能控制运行应用程序的托管环境配置<br>软件即服务 SasS: 提供给客户的服务是运营商运行在云计算基础设施上的应用程序，用户可以在各种设备上通过客户端界面访问，如浏览器。消费者不需要管理或控制任何云计算基础设施，包括网络、服务器、操作系统、存储等等；</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ol>
<li><p>杀毒：当发现有嫌疑的数据时，杀毒软件可以将有嫌疑的数据上传至云中，并通过云中庞大的特征库和强大的处理能力来分析这个数据是否含有病毒，这非常适合那些需要使用杀毒软件来捍卫其电脑安全的用户。</p>
</li>
<li><p>电子邮件</p>
</li>
</ol>
<p>由于各种不同的原因，我们都会有几个不同的邮箱。而常常查看这些邮箱的邮件，就变成一件很繁琐的事情，我们需要打开不同的网站，输入不同的用户名及密码。现在，云计算又可以发挥很大作用了。通过托管，邮件服务提供商可以将多个不同的邮件整合在一起。例如，谷歌的Gmail电子邮件服务，可以整合多个符合POP3标准的电子邮件，用户可以直接在Gmail的收件箱中直接收取到来自各个邮箱中的电子邮件。是不是方便了很多？</p>
<ol>
<li>地图导航</li>
</ol>
<p>在没有GPS的时代，每到一个地方，我们都需要购买当地的地图。以前经常可见路人拿着地图问路的情景。而现在，我们只需要一部手机，就可以拥有一张全世界的地图。甚至还能够得到地图上得不到的信息，例如交通路况，天气状况等等。正是基于云计算技术的GPS带给了我们这一切。地图，路况这些复杂的信息，并不需要预先装在我们的手机中，而是储存在服务提供商的“云”中，我们只需在手机上按一个键，就可以很快的找到我们所要找的地方。</p>
<ol>
<li>存储云<br>存储云，又称云存储，是在云计算技术上发展起来的一个新的存储技术。云存储是一个以数据存储和管理为核心的云计算系统。用户可以将本地的资源上传至云端上，可以在任何地方连入互联网来获取云上的资源。大家所熟知的谷歌、微软等大型网络公司均有云存储的服务，在国内，百度云和微云则是市场占有量最大的存储云。存储云向用户提供了存储容器服务、备份服务、归档服务和记录管理服务等等，大大方便了使用者对资源的管理。</li>
</ol>
<h1 id="13-4分治思想及其特征"><a href="#13-4分治思想及其特征" class="headerlink" title="13.4分治思想及其特征"></a>13.4分治思想及其特征</h1><p>分治思想就是将一个大规模的问题不断细分成子问题，子问题可以细分，子问题将很容易求解。<br>最终问题的解是所有子问题解的集合。<br>典型应用有汉诺塔，归并排序，快速排序。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/CS-BASIC/" rel="tag"># CS BASIC</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/03/15/ENGANS/" rel="prev" title="EngAns">
      <i class="fa fa-chevron-left"></i> EngAns
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/03/15/Introduction/" rel="next" title="Introduction">
      Introduction <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE"><span class="nav-number">1.</span> <span class="nav-text">区块链</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text">软件架构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-1-%E5%90%8C%E6%AD%A5%E5%92%8C%E4%BA%92%E6%96%A5"><span class="nav-number">3.</span> <span class="nav-text">1.1 同步和互斥</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">4.</span> <span class="nav-text">线程和进程的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E4%BA%94%E4%B8%AA%E7%89%B9%E6%80%A7%EF%BC%9A"><span class="nav-number">5.</span> <span class="nav-text">算法的五个特性：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#T-n-O-f-n"><span class="nav-number">6.</span> <span class="nav-text">T(n)&#x3D;O(f(n))</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%EF%BC%9A"><span class="nav-number">7.</span> <span class="nav-text">1.3人工智能：</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0"><span class="nav-number">7.1.</span> <span class="nav-text">机器学习</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%EF%BC%9A"><span class="nav-number">7.1.1.</span> <span class="nav-text">监督学习：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%EF%BC%9A"><span class="nav-number">7.1.2.</span> <span class="nav-text">无监督学习：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0"><span class="nav-number">7.1.3.</span> <span class="nav-text">强化学习:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%9A"><span class="nav-number">7.1.4.</span> <span class="nav-text">深度学习：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%84%E7%A7%8D%E7%BD%91%E7%BB%9C"><span class="nav-number">7.1.5.</span> <span class="nav-text">各种网络</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-2-%E7%89%A9%E8%81%94%E7%BD%91"><span class="nav-number">8.</span> <span class="nav-text">2.2 物联网</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">9.</span> <span class="nav-text">2.3 数据结构的作用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-4-WEB%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80"><span class="nav-number">10.</span> <span class="nav-text">2.4 WEB编程语言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-1-TCP"><span class="nav-number">11.</span> <span class="nav-text">3.1 TCP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">11.1.</span> <span class="nav-text">三次握手</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">11.2.</span> <span class="nav-text">四次挥手</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-2"><span class="nav-number">12.</span> <span class="nav-text">3.2</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-3"><span class="nav-number">13.</span> <span class="nav-text">3.3</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-4"><span class="nav-number">14.</span> <span class="nav-text">3.4</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#c-%E6%94%AF%E6%8C%81java%E4%B8%8D%E6%94%AF%E6%8C%81"><span class="nav-number">14.1.</span> <span class="nav-text">c++支持java不支持</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java%E6%94%AF%E6%8C%81c-%E4%B8%8D%E6%94%AF%E6%8C%81"><span class="nav-number">14.2.</span> <span class="nav-text">java支持c++不支持</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%83%BD%E6%94%AF%E6%8C%81%E7%9A%84%E4%BD%86%E6%9C%89%E5%8C%BA%E5%88%AB"><span class="nav-number">14.3.</span> <span class="nav-text">都支持的但有区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9F%E5%BA%A6"><span class="nav-number">14.4.</span> <span class="nav-text">速度</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-1"><span class="nav-number">15.</span> <span class="nav-text">4.1</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-2"><span class="nav-number">16.</span> <span class="nav-text">4.2</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E7%B1%BB"><span class="nav-number">16.1.</span> <span class="nav-text">分类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-3"><span class="nav-number">17.</span> <span class="nav-text">4.3</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-4"><span class="nav-number">18.</span> <span class="nav-text">4.4</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-1"><span class="nav-number">19.</span> <span class="nav-text">5.1</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-2"><span class="nav-number">20.</span> <span class="nav-text">5.2</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-3-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84"><span class="nav-number">21.</span> <span class="nav-text">5.3 软件架构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-4HPC"><span class="nav-number">22.</span> <span class="nav-text">5.4HPC</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-1-%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95"><span class="nav-number">23.</span> <span class="nav-text">6.1 路由算法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-2"><span class="nav-number">24.</span> <span class="nav-text">6.2</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-3-%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="nav-number">25.</span> <span class="nav-text">6.3 关系型数据库的查询优化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-4-%E5%9B%9B%E7%A7%8D%E6%95%B0%E6%8D%AE%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="nav-number">26.</span> <span class="nav-text">6.4 四种数据逻辑结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-1%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">27.</span> <span class="nav-text">7.1快速排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">27.1.</span> <span class="nav-text">时间复杂度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="nav-number">27.2.</span> <span class="nav-text">算法思想</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="nav-number">27.3.</span> <span class="nav-text">快速排序的特点：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-2%E5%A4%9A%E6%80%81%EF%BC%9A%E4%BA%8B%E7%89%A9%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%BD%A2%E6%80%81"><span class="nav-number">28.</span> <span class="nav-text">7.2多态：事物的多种形态</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="nav-number">28.1.</span> <span class="nav-text">多态的实现方式：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%9A%E6%80%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E5%B0%86%E8%99%9A%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E6%94%B9%E4%B8%BA%E9%87%8D%E5%86%99%E5%90%8E%E5%87%BD%E6%95%B0%E7%9A%84%E5%9C%B0%E5%9D%80"><span class="nav-number">28.2.</span> <span class="nav-text">C++虚函数多态实现原理:将虚表中的地址改为重写后函数的地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E5%A5%BD%E5%A4%84%EF%BC%9A"><span class="nav-number">28.3.</span> <span class="nav-text">多态好处：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%BC%8A%E7%AB%AF%EF%BC%9A"><span class="nav-number">28.4.</span> <span class="nav-text">多态的弊端：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A5%E5%85%85"><span class="nav-number">28.5.</span> <span class="nav-text">补充</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-3-IPv6%E4%B8%8EIPv4%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB"><span class="nav-number">29.</span> <span class="nav-text">7.3 IPv6与IPv4的区别与联系</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#IPv4%E5%88%B0IPv6%E8%BF%87%E6%B8%A1"><span class="nav-number">29.1.</span> <span class="nav-text">IPv4到IPv6过渡</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-1"><span class="nav-number">30.</span> <span class="nav-text">8.1</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-2-%E5%B8%B8%E8%A7%81%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95"><span class="nav-number">31.</span> <span class="nav-text">8.2 常见最短路径算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Folyd"><span class="nav-number">31.1.</span> <span class="nav-text">Folyd</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">31.1.1.</span> <span class="nav-text">算法实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dijkstra"><span class="nav-number">31.2.</span> <span class="nav-text">Dijkstra</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">31.2.1.</span> <span class="nav-text">算法实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-3"><span class="nav-number">32.</span> <span class="nav-text">8.3</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-4"><span class="nav-number">33.</span> <span class="nav-text">8.4</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-1"><span class="nav-number">34.</span> <span class="nav-text">9.1</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-2"><span class="nav-number">35.</span> <span class="nav-text">9.2</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%93%E6%98%AF%E5%86%99%E5%A5%BD%E7%9A%84%E7%8E%B0%E6%9C%89%E7%9A%84%EF%BC%8C%E6%88%90%E7%86%9F%E7%9A%84%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%A4%8D%E7%94%A8%E7%9A%84%E4%BB%A3%E7%A0%81%E3%80%82%E5%BA%93%E4%B8%AD%E8%99%BD%E7%84%B6%E5%8C%85%E5%90%AB%E4%BA%86%E5%8F%AF%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%8D%B4%E4%B8%8D%E8%83%BD%E5%8D%95%E7%8B%AC%E6%89%A7%E8%A1%8C"><span class="nav-number">35.1.</span> <span class="nav-text">库是写好的现有的，成熟的，可以复用的代码。库中虽然包含了可执行代码却不能单独执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E9%9D%99%E6%80%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">35.2.</span> <span class="nav-text">动态静态的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93"><span class="nav-number">35.3.</span> <span class="nav-text">静态链接库</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-3-TCP%E4%B8%8EUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">36.</span> <span class="nav-text">9.3 TCP与UDP的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-4-%E5%86%AF%C2%B7%E8%AF%BA%E4%BE%9D%E6%9B%BC"><span class="nav-number">37.</span> <span class="nav-text">9.4 冯·诺依曼</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BE%E7%81%B5%E6%9C%BA"><span class="nav-number">38.</span> <span class="nav-text">图灵机</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-1-RISC-CISC"><span class="nav-number">39.</span> <span class="nav-text">10.1 RISC CISC</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-2IP%E7%BB%84%E6%92%AD%EF%BC%9A"><span class="nav-number">40.</span> <span class="nav-text">10.2IP组播：</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E6%92%AD%E5%88%86%E7%B1%BB"><span class="nav-number">40.1.</span> <span class="nav-text">组播分类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-3"><span class="nav-number">41.</span> <span class="nav-text">10.3</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-4"><span class="nav-number">42.</span> <span class="nav-text">10.4</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-1-gt-8-1"><span class="nav-number">43.</span> <span class="nav-text">11.1 -&gt; 8.1</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-2"><span class="nav-number">44.</span> <span class="nav-text">11.2</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-3"><span class="nav-number">45.</span> <span class="nav-text">11.3</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">46.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="nav-number">46.1.</span> <span class="nav-text">产生死锁的必要条件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81"><span class="nav-number">46.2.</span> <span class="nav-text">预防死锁</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-4-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80"><span class="nav-number">47.</span> <span class="nav-text">11.4 汇编语言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-1%E5%B9%B3%E5%8F%B0%E6%97%A0%E5%85%B3%E6%80%A7"><span class="nav-number">48.</span> <span class="nav-text">12.1平台无关性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-2-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4"><span class="nav-number">49.</span> <span class="nav-text">12.2 数据库设计的基本步骤</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-3%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="nav-number">50.</span> <span class="nav-text">12.3驱动程序</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-4"><span class="nav-number">51.</span> <span class="nav-text">12.4</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9A%84%E9%98%B6%E6%AE%B5"><span class="nav-number">52.</span> <span class="nav-text">软件开发的阶段</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#13-1%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="nav-number">53.</span> <span class="nav-text">13.1软件需求分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">53.1.</span> <span class="nav-text">需求分析的过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91"><span class="nav-number">53.2.</span> <span class="nav-text">敏捷开发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%88%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B%EF%BC%89"><span class="nav-number">53.3.</span> <span class="nav-text">软件生命周期（软件过程模型）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9C%80%E6%B1%82%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">53.4.</span> <span class="nav-text">需求的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E7%BA%A6%E6%9D%9F"><span class="nav-number">53.4.1.</span> <span class="nav-text">性能约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BA%A6%E6%9D%9F"><span class="nav-number">53.4.2.</span> <span class="nav-text">外部接口的约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E7%BA%A6%E6%9D%9F"><span class="nav-number">53.4.3.</span> <span class="nav-text">设计约束</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9C%80%E6%B1%82%E5%8F%91%E7%8E%B0"><span class="nav-number">53.5.</span> <span class="nav-text">需求发现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9C%80%E6%B1%82%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%A7%E8%B4%A8"><span class="nav-number">53.6.</span> <span class="nav-text">需求的基本性质</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9C%80%E6%B1%82%E8%A7%84%E7%BA%A6SRS"><span class="nav-number">53.7.</span> <span class="nav-text">需求规约SRS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SRS%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">53.7.1.</span> <span class="nav-text">SRS的作用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#13-2TCP-IP%E6%AF%8F%E5%B1%82%E7%94%A8%E7%9A%84%E5%8D%8F%E8%AE%AE"><span class="nav-number">54.</span> <span class="nav-text">13.2TCP&#x2F;IP每层用的协议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-IP-%E5%9B%9B%E5%B1%82"><span class="nav-number">54.1.</span> <span class="nav-text">TCP&#x2F;IP 四层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#A-%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="nav-number">54.2.</span> <span class="nav-text">A 应用层协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="nav-number">54.3.</span> <span class="nav-text">B 传输层协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="nav-number">54.4.</span> <span class="nav-text">C 网络层协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#D-%E6%95%B0%E6%8D%AE%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="nav-number">54.5.</span> <span class="nav-text">D 数据层协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#E-%E7%89%A9%E7%90%86%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="nav-number">54.6.</span> <span class="nav-text">E 物理层协议</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#13-3"><span class="nav-number">55.</span> <span class="nav-text">13.3</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%B1%BB%E5%9E%8B"><span class="nav-number">55.1.</span> <span class="nav-text">服务类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8"><span class="nav-number">55.2.</span> <span class="nav-text">应用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#13-4%E5%88%86%E6%B2%BB%E6%80%9D%E6%83%B3%E5%8F%8A%E5%85%B6%E7%89%B9%E5%BE%81"><span class="nav-number">56.</span> <span class="nav-text">13.4分治思想及其特征</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Finyaci</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">84</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Finyaci</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
